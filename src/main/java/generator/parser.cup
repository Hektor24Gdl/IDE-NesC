
/* ---------------Seccion de declaraciones preliminares--------------------*/
package code; 

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
import code.ast.*;

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:


    private Component component;
    private ParserError error = new ParserError();

    public ParserError getError(){
        return error;
    }
    public void setComponent(Component component) {
        this.component = component;
    }
    
    public Component getComponent() {
        return component;
    }
     /* Change the method report_error so it will display the line
     * and column of where the error occurred in the input as well
     * as the reason for the error which is passed into the method
     * in the String 'message'.  */
    public void report_error(String message, Object info) {

        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer("Error");
	int unexpectedToken = 0;

        /* Check if the information passed to the method is the same type
         * as the type java_cup.runtime.Symbol.  */ 
        if (info instanceof java_cup.runtime.Symbol) {

            /* Declare a java_cup.runtime.Symbol object 's' with the
             * information in the object info that is being typecasted
             * as a java_cup.runtime.Symbol object.  */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            /* Check if the line number in the input is greater or
             * equal to zero.  */
            if (s.left >= 0) {

		unexpectedToken = s.sym;

                /* Add to the end of the StringBuffer error message the
                 * line number of the error in the input. */
                m.append(" in line " + (s.left + 1));
		error.setLine(s.left + 1);

                /* Check if the column number in the input is greater
                 * or equal to zero */
                if (s.right >= 0) {

                    /* Add to the end of the StringBuffer error message
                     * the column number of the error in the input.  */
                    m.append(", column " + (s.right + 1));
		    error.setColumn(s.right + 1);
                }
            }
        }
	error.setMessage(message + " Unspected Token: "  + unexpectedToken);
        /* Add to the end of the StringBuffer error message created in this
           method the message that was passed into this method. */
        m.append(" : " + message);

        /* Print the contents of the StringBuffer 'm', which contains an
         * error message out on a line. */
        //System.err.println(m);
    }


    /* Change the method report_fatal_error so when it reports a fatal
     * error it will display the line and column number of where the fatal
     * error occurred in the input as well as the reason for the fatal
     * error which is passed into the method in the object 'message' and
     * then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new Error("Parser Error");
        //System.exit(1);
    }
 
:};
   
/* ------------Declaration of Terminals and Non Terminals Section----------- */

/* Terminals (tokens returned by the scanner).
 *
 * Terminals that have no value are listed first and then terminals that
 * do have an value, in this case an integer value, are listed on the
 * next line down.
 */ 
terminal INCLUDES;
terminal CONFIGURATION;
terminal PROVIDES;
terminal USES;
terminal INTERFACE;
terminal IMPLEMENTATION;
terminal COMPONENT;
terminal COMPONENTS;
terminal AS;
terminal SEMI_COLON;
terminal OPEN_PAREN;
terminal CLOSE_PAREN;
terminal OPEN_CURLY;
terminal CLOSE_CURLY;
terminal COMMA;
terminal DOT;
terminal OPEN_BRACE;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal MOD;
terminal LSHIFT;
terminal RSHIFT;
terminal LESS_THAN;
terminal GREATER_THAN;
terminal EQCOMPARE;
terminal BITWISE_AND;
terminal BITWISE_OR;
terminal BITWISE_NOT;
terminal AND;
terminal OR;
terminal QUESTION;
terminal COLON;
terminal ATOMIC;
terminal FALSE;
terminal NEW;
terminal THIS;
terminal TRUE;
terminal USING;
terminal TASK;
terminal POST;
terminal NAMESPACE;
terminal EVENT;
terminal COMMAND;
terminal MODULE;
terminal TYPENAME;
terminal TEMPLATE;
terminal VIRTUAL;
terminal IF;
terminal ELSE;
terminal FOR;
terminal WHILE;
terminal RETURN;
terminal BREAK;
terminal SWITCH;
terminal CASE;
terminal DEFAULT;
terminal DO;
terminal CONTINUE;
terminal UINT8_T;
terminal UINT16_T;
terminal UINT32_T;
terminal INT8_T;
terminal INT16_T;
terminal INT32_T;
terminal EXPLICIT;
terminal EXPORT;
terminal INLINE;
terminal ERROR_T;
terminal RESULT_T;
terminal PACKET_T;
terminal MESSAGE_T;
terminal STRUCT;
terminal ENUM;
terminal BOOL;
terminal CHAR;
terminal INT;
terminal VOID;
terminal GOTO;
terminal LESS_EQUAL_THAN;
terminal GREATER_EQUAL_THAN;
terminal EQNOT_EQUAL;
terminal NOT;
terminal BITWISE_XOR;

terminal java.lang.Integer INTEGER;
terminal FLOAT;
terminal java.lang.String  STRING;
terminal java.lang.String  CHARACTER;
terminal java.lang.String  WIRES_TO;
terminal java.lang.String  WIRES_FROM;
terminal java.lang.String  EQUALS;
terminal java.lang.String  PREPROCESSOR;
terminal java.lang.String  CLOSE_BRACE;
terminal java.lang.String  IDENTIFIER;
terminal java.lang.Integer INTEGER_LITERAL;

terminal CALL;

/* Non Terminals used in the Grammar Section.
 *
 * Non Terminals that have an object value are listed first and then Non
 * Terminals that have an integer value are listed.  An object value means
 * that it can be any type, it isn't set to a specific type.  So it could
 * be an integer or a String or whatever.
 */
//non terminal nonNullExprList;
//non terminal exprNoCommas;
//non terminal castExpr;
//non terminal primary;
//non terminal Object     parms;
//non terminal Object     parm;

non terminal dispatch;
non terminal                   component;
non terminal                    ncHeader;
non terminal                includesList;
non terminal                    includes;
non terminal                 includeList;
non terminal               configuration;
non terminal      requiresOrProvidesList;
non terminal          requiresOrProvides;
non terminal  requires;
non terminal  provides;
non terminal  parameterisedInterfaceList;
non terminal     parameterisedInterfaces;
non terminal      parameterisedInterface;
non terminal                interfaceRef;
non terminal java.lang.String           interfaceType;
non terminal java.lang.String           parameters;
non terminal              iconfiguration;
non terminal          configurationDecls;
non terminal           configurationDecl;
non terminal                  connection;
non terminal                    endpoint;
non terminal     parameterisedIdentifier;
non terminal                       cuses;
non terminal               componentList;
non terminal                componentRef;

non terminal implementation_content;
non terminal statement;
non terminal statement_list;

non terminal components_list;
non terminal component_list;
non terminal statement_implementation_list;
non terminal statement_implementation;
non terminal identifier_pro;
non terminal type_list;
non terminal types_set;
non terminal module_list;
non terminal module_statement_list;
non terminal module_statement;
non terminal statement_advanced_implementation_list;
non terminal statement_advanced_implementation;
non terminal statement_advanced_implementation_items;
non terminal statement_advanced_implementation_item;
non terminal statement_advanced_implementation_return_item;
non terminal identifier_value_list;
non terminal values_set;

/* -------------Precedence and Associatively of Terminals Section----------- */

/* Precedence of Non Terminals could be defined here.  If you do define
 * precedence here you won't need to worry about precedence in the Grammar
 * Section.  i.e. that TIMES should have a higher precedence than PLUS.
 *
 * The precedence defined here would look something like this where the lower
 * line always will have higher precedence than the line before it.
 *
 * precedence left PLUS, MINUS;
 * precedence left TIMES, DIVIDE;
 */

precedence left EQUALS;
precedence right QUESTION, COLON;
precedence left OR;
precedence left AND;
precedence left BITWISE_OR;
precedence left BITWISE_NOT;
precedence left BITWISE_AND;
precedence left EQCOMPARE;
precedence left LESS_THAN, GREATER_THAN;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left WIRES_TO, DOT, OPEN_PAREN, OPEN_BRACE;

/* ---------------------------------Grammar Section------------------------- */

/* The grammar for our parser.

        expr_list ::=   expr_list expr_part
                        | expr_part
        expr_part ::=   expr SEMI
        expr      ::=   factor PLUS expr
                        | factor MINUS expr
                        | factor
        factor    ::=   factor TIMES term
                        | factor DIVIDE term
                        | term
        primary   ::=   LPAREN expr RPAREN
                        | NUMBER
                        | ID

*/

start with dispatch;
 
dispatch                                      ::=
						INTERFACE IDENTIFIER OPEN_CURLY statement_list CLOSE_CURLY
						{:
						     System.out.println("interface");
						:}
						|
						CONFIGURATION IDENTIFIER OPEN_CURLY CLOSE_CURLY
						IMPLEMENTATION OPEN_CURLY implementation_content CLOSE_CURLY
						{: :}
						| MODULE IDENTIFIER OPEN_CURLY module_list CLOSE_CURLY					 IMPLEMENTATION OPEN_CURLY implementation_content CLOSE_CURLY
						{: :}
						;

module_list                                   ::= module_list module_statement_list 
                                                | module_statement_list
                                                ;

module_statement_list                         ::= PROVIDES OPEN_CURLY module_statement CLOSE_CURLY 
                                                | USES OPEN_CURLY module_statement CLOSE_CURLY ;

module_statement                              ::= module_statement INTERFACE IDENTIFIER SEMI_COLON
                                                | /*epsilon*/
                                                ;

implementation_content                        ::= components_list  statement_implementation_list 
                                                | statement_advanced_implementation_list 
                                                | /*epsilon*/
                                                ;

components_list                               ::= COMPONENTS component_list SEMI_COLON | /*epsilon*/;

component_list                                ::= component_list COMMA IDENTIFIER | IDENTIFIER;

statement_list                                ::= statement_list statement | statement;

statement_advanced_implementation_list        ::= statement_advanced_implementation_list statement_advanced_implementation 
                                                | statement_advanced_implementation;

statement_advanced_implementation             ::= COMMAND RESULT_T IDENTIFIER DOT IDENTIFIER OPEN_PAREN identifier_value_list CLOSE_PAREN OPEN_CURLY statement_advanced_implementation_items CLOSE_CURLY 
                                                | EVENT RESULT_T IDENTIFIER DOT IDENTIFIER OPEN_PAREN identifier_value_list CLOSE_PAREN OPEN_CURLY statement_advanced_implementation_items CLOSE_CURLY
                                                ; 

statement_advanced_implementation_items       ::= statement_advanced_implementation_items statement_advanced_implementation_return_item
                                                | statement_advanced_implementation_item 
						|/*epsilon*/
						;

statement_advanced_implementation_return_item ::= RETURN statement_advanced_implementation_item;

statement_advanced_implementation_item        ::= CALL IDENTIFIER DOT IDENTIFIER OPEN_PAREN identifier_value_list CLOSE_PAREN SEMI_COLON 
                                                | IDENTIFIER SEMI_COLON;

identifier_value_list                         ::= identifier_value_list COMMA IDENTIFIER 
                                                | identifier_value_list COMMA values_set 
                                                | values_set 
                                                | IDENTIFIER 
                                                | /*epsilon*/
                                                ;

values_set                                    ::= INTEGER | FLOAT | CHARACTER | STRING;
statement                                     ::=  
                                                  COMMAND RESULT_T IDENTIFIER OPEN_PAREN type_list CLOSE_PAREN SEMI_COLON
					          {:
							System.out.println("statement");
    						  :}
   						| EVENT RESULT_T IDENTIFIER OPEN_PAREN type_list CLOSE_PAREN SEMI_COLON
						{:
							System.out.println("statement");
					        :}
					        ;

type_list                                     ::= type_list COMMA types_set IDENTIFIER | types_set IDENTIFIER | /*epsilon*/ ;

types_set                                     ::= CHAR | UINT8_T | UINT16_T | UINT32_T | INT8_T | INT16_T | INT32_T |EXPLICIT | EXPORT 
						|INLINE | ERROR_T | RESULT_T | PACKET_T | MESSAGE_T | STRUCT | ENUM | BOOL | INT;

statement_implementation_list                 ::= statement_implementation_list statement_implementation | statement_implementation;

statement_implementation                      ::=
						identifier_pro WIRES_TO identifier_pro SEMI_COLON
						{:
						System.out.println("statement");
						:}
						;

identifier_pro                                ::= identifier_pro DOT IDENTIFIER | IDENTIFIER  ;
    

/* vim: :set ft=java: */
