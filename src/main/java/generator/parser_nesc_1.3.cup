
/* ---------------Seccion de declaraciones preliminares--------------------*/
package code; 

import java_cup.runtime.*;

import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import exceptions.*;

/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:


    private GenericError error = new GenericError();

    public GenericError getError(){
        return error;
    }

     /* Change the method report_error so it will display the line
     * and column of where the error occurred in the input as well
     * as the reason for the error which is passed into the method
     * in the String 'message'.  */
    public void report_error(String message, Object info) {

        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer("Error");
		int unexpectedToken = 0;
        String value = "";
        /* Check if the information passed to the method is the same type
         * as the type java_cup.runtime.Symbol.  */ 
        if (info instanceof java_cup.runtime.Symbol) {

            /* Declare a java_cup.runtime.Symbol object 's' with the
             * information in the object info that is being typecasted
             * as a java_cup.runtime.Symbol object.  */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            /* Check if the line number in the input is greater or
             * equal to zero.  */
            if (s.left >= 0) {

				unexpectedToken = s.sym;
                value = (String)s.value;
                /* Add to the end of the StringBuffer error message the
                 * line number of the error in the input. */
                m.append(" in line " + (s.left + 1));
				error.setLine(s.left + 1);

                /* Check if the column number in the input is greater
                 * or equal to zero */
                if (s.right >= 0) {

                    /* Add to the end of the StringBuffer error message
                     * the column number of the error in the input.  */
                    m.append(", column " + (s.right + 1));
		    error.setColumn(s.right + 1);
                }
            }
        }
		HashMap<Integer, String> tokens=null;
   	    try {
      	    tokens = new Lexer().getTokens();
    	} catch (IllegalArgumentException ex) {
          Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
     	} catch (IllegalAccessException ex) {
          Logger.getLogger(Parser.class.getName()).log(Level.SEVERE, null, ex);
      	}
      	String messageToken = (value!=null) ? tokens.get(unexpectedToken) +" <" +value +">"  : tokens.get(unexpectedToken)  ; 
		error.setMessage(message + " Unspected Token: "  + messageToken);
        /* Add to the end of the StringBuffer error message created in this
           method the message that was passed into this method. */
        m.append(" : " + message);

        /* Print the contents of the StringBuffer 'm', which contains an
         * error message out on a line. */
        //System.err.println(m);
    }

 	public void report_fatal_error(String message, Object info){
        report_error(message, info);
        throw new Error(message);
	}
:};
   
/* ------------Declaration of Terminals and non terminal Objects Section----------- */

/* Terminals (tokens returned by the scanner).
 *
 * Terminals that have no value are listed first and then terminals that
 * do have an value, in this case an integer value, are listed on the
 * next line down.
 */ 
//LENGUAJE C
terminal Object IDENTIFIER;
terminal Object CONSTANT;
terminal Object STRING_LITERAL;
//terminal PTR_OP; 
terminal INC_OP;
terminal DEC_OP;
terminal LEFT_OP;
terminal RIGHT_OP;
terminal LE_OP;
terminal GE_OP;
terminal EQ_OP NE_OP;
terminal AND_OP;
terminal OR_OP;
terminal MUL_ASSIGN;
terminal DIV_ASSIGN;
terminal MOD_ASSIGN;
terminal ADD_ASSIGN;
terminal SUB_ASSIGN;
terminal LEFT_ASSIGN;
terminal RIGHT_ASSIGN;
terminal AND_ASSIGN;
terminal XOR_ASSIGN;
terminal OR_ASSIGN;
terminal TYPE_NAME;
terminal ABSTRACT;

terminal STATIC;
terminal CHAR;
terminal SHORT;
terminal INT;
terminal LONG;
terminal UNSIGNED;
terminal FLOAT;
terminal DOUBLE;
terminal CONST;
terminal VOID;
terminal STRUCT;
terminal ENUM;

terminal CASE;
terminal DEFAULT;
terminal IF;
terminal ELSE;
terminal SWITCH;
terminal WHILE;
terminal DO; 
terminal FOR;
terminal GOTO;
terminal CONTINUE;
terminal BREAK;
terminal RETURN;
terminal OPEN_PAREN;
terminal CLOSE_PAREN;
terminal CLOSE_BRACE;
terminal OPEN_BRACE;
terminal OPEN_CURLY;
terminal CLOSE_CURLY;
terminal COMMA;
terminal DOT;
terminal MULTIPLICATION;
terminal COLON;
terminal BITWISE_OR;
terminal GREATER_THAN;
terminal EQUALS;
terminal LESS_THAN;
terminal PLUS;
terminal BITWISE_AND;
terminal SEMI_COLON;
terminal NOT;
terminal TERNARY;
terminal BITWISE_NOT;
terminal PREPROCESSOR;
terminal MINUS;
terminal DIVIDE;
terminal MOD;
terminal BITWISE_XOR;
terminal EQ_OP;
terminal SIGNED;
terminal SIZEOF;
terminal UNION;
terminal VOLATILE;
terminal ELLIPSIS;
terminal EXTERN;

terminal TYPEDEF;
terminal INCLUDE;
//NESC
terminal AS;
terminal ATOMIC;
terminal ASYNC;
terminal CALL;
terminal COMMAND;
terminal COMPONENT;
terminal COMPONENTS;
terminal CONFIGURATION;
terminal EVENT;
terminal GENERIC;
terminal IMPLEMENTATION;
terminal INCLUDES;
terminal INTERFACE;
terminal MODULE;
terminal NEW;
terminal NORACE;
terminal NX_STRUCT;
terminal NX_UNION;
terminal POST;
terminal PROVIDES;
terminal SIGNAL;
terminal TASK;
terminal USES; 

terminal WIRES_TO;
terminal WIRES_FROM;
terminal AT;
terminal ATTRIBUTE;

terminal Object FALSE;
terminal THIS;
terminal Object TRUE;
terminal USING;
terminal NAMESPACE;
terminal TYPENAME;
terminal TEMPLATE;
terminal VIRTUAL;
terminal UINT8_T;
terminal UINT16_T;
terminal UINT32_T;
terminal INT8_T;
terminal INT16_T;
terminal INT32_T;
terminal BOOL;
terminal EXPLICIT;
terminal EXPORT;
terminal INLINE;
terminal ERROR_T;
terminal RESULT_T;
terminal PACKET_T;
terminal MESSAGE_T;


/* words reserved for nesC's future. Some may never be used... */
terminal ABSTRACT EXTENDS;






/* non terminal Objects used in the Grammar Section.
 *
 * non terminal Objects that have an object value are listed first and then Non
 * Terminals that have an integer value are listed.  An object value means
 * that it can be any type, it isn't set to a specific type.  So it could
 * be an integer or a String or whatever.
 */


/*non terminal Object for c*/
non terminal Object primary_expression;
non terminal Object postfix_expression;
non terminal Object argument_expression_list;
non terminal Object unary_expression;
non terminal Object unary_operator;
non terminal Object cast_expression;
non terminal Object multiplicative_expression;
non terminal Object additive_expression;
non terminal Object shift_expression;
non terminal Object relational_expression;
non terminal Object equality_expression;
non terminal Object and_expression;
non terminal Object exclusive_or_expression;
non terminal Object inclusive_or_expression;
non terminal Object logical_and_expression;
non terminal Object logical_or_expression;
non terminal Object conditional_expression;
non terminal Object assignment_expression;
non terminal Object assignment_operator;
non terminal Object expression;
non terminal Object constant_expression;
non terminal Object declaration;
non terminal Object declaration_specifiers;
non terminal Object init_declarator_list;
non terminal Object init_declarator;
non terminal Object storage_class_specifier;
non terminal Object type_specifier;
non terminal Object struct_or_union_specifier;
non terminal Object struct_or_union;
non terminal Object struct_declaration_list;
non terminal Object struct_declaration;
non terminal Object specifier_qualifier_list;
non terminal Object struct_declarator_list;
non terminal Object struct_declarator;
non terminal Object enum_specifier;
non terminal Object enumerator_list;
non terminal Object enumerator;
non terminal Object type_qualifier;
non terminal Object declarator;
non terminal Object direct_declarator;
non terminal Object pointer;
non terminal Object type_qualifier_list;
non terminal Object parameter_type_list;
non terminal Object parameter_list;
non terminal Object parameter_declaration;
non terminal Object identifier_list;
non terminal Object type_name;
non terminal Object abstract_declarator;
non terminal Object direct_abstract_declarator;
non terminal Object initializer;
non terminal Object initializer_list;
non terminal Object statement;
non terminal Object labeled_statement;
non terminal Object compound_statement;
non terminal Object declaration_list;
non terminal Object statement_list;
non terminal Object expression_statement;
non terminal Object selection_statement;
non terminal Object iteration_statement;
non terminal Object jump_statement;
non terminal Object translation_unit;
non terminal Object external_declaration;
non terminal Object function_definition;


/*non terminal Object for nesC*/
non terminal Object nesC_file;
non terminal Object interface_definition;
non terminal Object type_parameters;
non terminal Object type_parameter_list;
non terminal Object component;
non terminal Object comp_kind;
non terminal Object implementation;
non terminal Object comp_parameters;
non terminal Object component_parameter_list;
non terminal Object component_parameter;
non terminal Object module_implementation;
non terminal Object configuration_implementation;
non terminal Object configuration_element_list;
non terminal Object configuration_element;
non terminal Object components;
non terminal Object component_line;
non terminal Object instance_name;
non terminal Object component_ref;
non terminal Object component_argument_list;
non terminal Object component_argument;
non terminal Object connection;
non terminal Object endpoint;
non terminal Object identifier_path;
non terminal Object component_specification;
non terminal Object uses_provides_list;
non terminal Object uses_provides;
non terminal Object specification_element_list;
non terminal Object specification_elements;
non terminal Object specification_element;
non terminal Object interface_type;
non terminal Object type_arguments;
non terminal Object type_arguments_list;
non terminal Object instance_parameters;
non terminal Object attributes;
non terminal Object attribute;

non terminal Object call_kind;
non terminal Object atomic_statement;

non terminal Object primary;
non terminal Object constant;
non terminal Object include_list;

/* -------------Precedence and Associatively of Terminals Section----------- */

/* Precedence of non terminal Objects could be defined here.  If you do define
 * precedence here you won't need to worry about precedence in the Grammar
 * Section.  i.e. that TIMES should have a higher precedence than PLUS.
 *
 * The precedence defined here would look something like this where the lower
 * line always will have higher precedence than the line before it.
 *
 * precedence left PLUS, MINUS;
 * precedence left TIMES, DIVIDE;
 */

precedence left EQUALS;
precedence right TERNARY, COLON;
precedence left OR_OP;
precedence left AND_OP;
precedence left BITWISE_OR;
precedence left BITWISE_NOT;
precedence left BITWISE_AND;
precedence left EQ_OP;
precedence left LESS_THAN, GREATER_THAN;
precedence left LEFT_OP, RIGHT_OP;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVIDE, MOD;
precedence left WIRES_TO, DOT, OPEN_PAREN, OPEN_BRACE;

precedence left AT;
precedence left COMMA;
precedence left IDENTIFIER;
precedence left VOID,CHAR,SHORT,INT,LONG,FLOAT,DOUBLE,SIGNED,UNSIGNED;

/* ---------------------------------Grammar Section------------------------- */

/* The grammar for our parser.

        expr_list ::=   expr_list expr_part
                        | expr_part
        expr_part ::=   expr SEMI
        expr      ::=   factor PLUS expr
                        | factor MINUS expr
                        | factor
        factor    ::=   factor TIMES term
                        | factor DIVIDE term
                        | term
        primary   ::=   LPAREN expr RPAREN
                        | NUMBER
                        | ID

*/

start with nesC_file;

nesC_file    	        	   	::= 
								include_list component:c
								{: System.err.println((String)c); :}
								|
                    		    include_list interface_definition
								|
								include_list translation_unit interface_definition
                    		    |
                    		    include_list translation_unit component:c
                    		    {: System.err.println((String)c); :}
								;

include_list 					::=
								include_list INCLUDE STRING_LITERAL
								|
								INCLUDE STRING_LITERAL
								|/*epsilon*/
								;

interface_definition			::=
								INTERFACE IDENTIFIER:i type_parameters attributes OPEN_CURLY declaration_list CLOSE_CURLY
								{: System.err.println(sym.INTERFACE + " - - - " + i); :}
								|
								INTERFACE IDENTIFIER:i attributes OPEN_CURLY declaration_list CLOSE_CURLY
								{: System.err.println(sym.INTERFACE + " - - - " + i); :}
								|
								INTERFACE IDENTIFIER:i type_parameters OPEN_CURLY declaration_list CLOSE_CURLY
								{: System.err.println(sym.INTERFACE + " - - - " + i); :}
								|
								INTERFACE IDENTIFIER:i OPEN_CURLY declaration_list CLOSE_CURLY
								{: System.err.println(sym.INTERFACE + " - - - " + i); :}
								;


type_parameters					::=
								LESS_THAN type_parameter_list GREATER_THAN
								;

type_parameter_list				::=
								IDENTIFIER:i attributes
								| 
								IDENTIFIER:i
								|
								type_parameter_list COMMA IDENTIFIER:i attributes
								|
								type_parameter_list COMMA IDENTIFIER:i
								;

component 						::=
								comp_kind IDENTIFIER:i comp_parameters attributes component_specification implementation:im
								{: /*RESULT = (Object)((String)i + " --- " +(String)im);*/ :}
								|
								comp_kind IDENTIFIER:i attributes component_specification implementation:im
								{: /* RESULT = (Object)((String)i + " --- " +(String)im); */:}
								|
								comp_kind IDENTIFIER:i comp_parameters component_specification implementation:im
								{: /*RESULT = (Object)((String)i + " --- " +(String)im); */:}
								|
								comp_kind IDENTIFIER:i comp_parameters attributes component_specification
								{: System.err.println("" + i); :}
								|
								comp_kind IDENTIFIER:i comp_parameters component_specification
								{: System.err.println("" + i); :}
								|
								comp_kind IDENTIFIER:i attributes component_specification
								{: System.err.println("" + i); :}
								|
								comp_kind IDENTIFIER:i component_specification implementation:im
								{: /*RESULT = (Object)((String)i + " --- " +(String)im); */:}
								|
								comp_kind IDENTIFIER:i component_specification
								{: System.err.println("" + i  ); :}
								;

comp_kind						::=
								MODULE
								{: System.err.println("MOD " + sym.MODULE); :}
								|
								COMPONENT
								{: System.err.println("COMP " + sym.MODULE);  :}
								|
								CONFIGURATION
								{: System.err.println("CONF " + sym.MODULE);  :}
								|
								GENERIC MODULE
								{: System.err.println("GM " + sym.MODULE);  :}
								|
								GENERIC CONFIGURATION
								{: System.err.println("GC " + sym.MODULE);  :}
								;

implementation 					::=
								module_implementation:m
								{: /*RESULT = m; */:}
								|
								configuration_implementation:c
								{: /*RESULT = c; */:}
								;

comp_parameters	 				::=
								OPEN_PAREN component_parameter_list CLOSE_PAREN
								|
								OPEN_PAREN  CLOSE_PAREN
								;

component_parameter_list		::=
								component_parameter_list COMMA component_parameter
								|
								component_parameter
								;

component_parameter 			::=
								parameter_declaration
								|
								TYPEDEF IDENTIFIER:i attributes
								|
								TYPEDEF IDENTIFIER:i
								;

module_implementation			::=
								IMPLEMENTATION OPEN_CURLY translation_unit CLOSE_CURLY
								;

configuration_implementation	::=
								IMPLEMENTATION OPEN_CURLY configuration_element_list:c CLOSE_CURLY
								{: /*RESULT = c;*/ :}
								|
								IMPLEMENTATION OPEN_CURLY CLOSE_CURLY
								;

configuration_element_list		::=
								configuration_element:e
								{: /*RESULT = e; */:}
								|
								configuration_element_list:l configuration_element:c
								{:/* RESULT = (Object)((String)l + " --- " + (String)c); */:}
								;

configuration_element 			::=
								components
								|
								connection:c
								{: /*RESULT = c; */:}
								|
								declaration:d
								{: /*RESULT = d;*/ :}
								;

components 						::=
								COMPONENTS component_line SEMI_COLON
								;

component_line 					::=
								component_ref instance_name
								|
								component_ref
								|
								component_line COMMA component_ref instance_name
								|
								component_line COMMA component_ref
								;

instance_name					::=
								AS IDENTIFIER:i
								;

component_ref 					::=
								IDENTIFIER:i
								|
								NEW IDENTIFIER:i OPEN_PAREN component_argument_list CLOSE_PAREN
								|
								NEW IDENTIFIER:i OPEN_PAREN CLOSE_PAREN
								;

component_argument_list			::=
								component_argument
								|
								component_argument_list COMMA component_argument
								;

component_argument 				::=
								expression
								|
								type_name
								;

connection 						::=
								endpoint:e EQUALS endpoint:p SEMI_COLON
								{: /*RESULT = (Object)((String)e + " = " + (String)p); */:}
								|
								endpoint:e WIRES_TO endpoint:p SEMI_COLON
								{:/* RESULT = (Object)((String)e + " -> " + (String)p); */:}
								|
								endpoint:e WIRES_FROM endpoint:p SEMI_COLON
								{: /*RESULT = (Object)((String)e + " <- " + (String)p); */:}
								;

endpoint 						::=
								identifier_path:i
								{: /*RESULT = (Object)((String)i); */:}
								|
								identifier_path:i OPEN_BRACE argument_expression_list:a CLOSE_BRACE
								{: /*RESULT = (Object)((String)i + " --- " + (String)a); */:}
								;

identifier_path					::=
								identifier_path:p DOT IDENTIFIER:i
								{: /*RESULT = (Object)((String)p + " --- " + (String)i); */:}
								|
								IDENTIFIER:i
								{:/* RESULT = (Object)(String)i; */:}
								;

component_specification 		::=
								OPEN_CURLY uses_provides_list CLOSE_CURLY
								|
								OPEN_CURLY CLOSE_CURLY
								;

uses_provides_list 				::=
								uses_provides
								|
								uses_provides_list uses_provides
								;

uses_provides 					::=
								USES specification_element_list
								|
								PROVIDES specification_element_list
								|
								declaration
								;

specification_element_list 		::=
								specification_element
								|
								OPEN_CURLY specification_elements CLOSE_CURLY
								;

specification_elements 			::=
								specification_elements specification_element
								|
								specification_element
								;

specification_element 			::=
								declaration
								{: System.out.println("specification_element: 1111111111111111111111111111111111"); :}
								|
								interface_type instance_name instance_parameters attributes
								{: System.out.println("specification_element: 222222222222222222222222222222222"); :}
								|
								interface_type instance_parameters attributes
								{: System.out.println("specification_element: 333333333333333333333333333333333"); :}
								|
								interface_type instance_name attributes
								{: System.out.println("specification_element: 444444444444444444444444444444444"); :}
								|
								interface_type instance_name instance_parameters
								{: System.out.println("specification_element: 55555555555555555555555555555555"); :}
								|
								interface_type instance_name
								{: System.out.println("specification_element: 66666666666666666666666666666666666666"); :}
								|
								interface_type instance_parameters
								{: System.out.println("specification_element: 7777777777777777777777777777777777777"); :}
								|
								interface_type attributes
								{: System.out.println("specification_element: 88888888888888888888888888888888888888"); :}
								|
								interface_type
								{: System.out.println("specification_element: 9999999999999999999999999999999999999"); :}
								;

interface_type					::=
								INTERFACE IDENTIFIER:i SEMI_COLON
								|
								INTERFACE IDENTIFIER:i instance_name SEMI_COLON
								|
								INTERFACE IDENTIFIER:i type_arguments SEMI_COLON
								;

type_arguments 					::=
								LESS_THAN type_arguments_list GREATER_THAN
								|
								LESS_THAN IDENTIFIER GREATER_THAN
								|
								LESS_THAN type_arguments_list GREATER_THAN instance_name
								|
								LESS_THAN IDENTIFIER GREATER_THAN instance_name
								;

type_arguments_list 			::=
								type_name
								|
								type_arguments_list COMMA type_name
								;

instance_parameters 			::=
								OPEN_BRACE parameter_type_list CLOSE_BRACE
								;

attributes						::=
								attributes attribute
								|
								attribute
								;

attribute 						::=
								AT IDENTIFIER:i OPEN_PAREN initializer_list CLOSE_PAREN
								|
								AT IDENTIFIER:i OPEN_PAREN CLOSE_PAREN
								;


primary::=
    IDENTIFIER:i
    {: :}
  | IDENTIFIER:i DOT IDENTIFIER:e
  | constant {: :}
  | OPEN_PAREN expression CLOSE_PAREN
    {: :}
  | OPEN_PAREN error CLOSE_PAREN
    {: System.err.println("Error");    :}
  |function_definition
    {: :}
    ;
constant ::= CONSTANT:c | TRUE:c | FALSE:c | STRING_LITERAL:c;

/*ANSI C*/

primary_expression
    ::= IDENTIFIER:i
    | constant
    | OPEN_PAREN expression CLOSE_PAREN
    ;
/* for ansi c
postfix_expression
    ::= primary_expression
    | postfix_expression OPEN_BRACE expression CLOSE_BRACE
    | postfix_expression OPEN_PAREN CLOSE_PAREN
    | postfix_expression OPEN_PAREN argument_expression_list CLOSE_PAREN
    | postfix_expression DOT IDENTIFIER:i
    | postfix_expression PTR_OP IDENTIFIER:i
    | postfix_expression INC_OP
    | postfix_expression DEC_OP
    ;

    */
    postfix_expression
    ::= primary_expression
    | postfix_expression OPEN_BRACE expression CLOSE_BRACE
    | call_kind primary OPEN_PAREN argument_expression_list:a CLOSE_PAREN
     {: /*RESULT =  (Object)(String)a; */:}
    | primary OPEN_PAREN argument_expression_list:a CLOSE_PAREN
    {: /*RESULT =  (Object)(String)a; */:}
    | call_kind primary OPEN_PAREN CLOSE_PAREN
    | primary OPEN_PAREN CLOSE_PAREN
    | primary_expression OPEN_PAREN CLOSE_PAREN
    | postfix_expression DOT IDENTIFIER:i
    | postfix_expression WIRES_TO IDENTIFIER:i
    | postfix_expression INC_OP
    | postfix_expression DEC_OP
    ;
    /*call for nesc*/
    call_kind ::= CALL | SIGNAL | POST;

argument_expression_list
    ::= assignment_expression:a
    {: /*RESULT =  (Object)(String)a;*/ :}
    | argument_expression_list:e COMMA assignment_expression:a
   // {: RESULT =  (Object)((String)e + " --- " + (String)a); :}
    ;

unary_expression
    ::= postfix_expression
    | INC_OP unary_expression
    | DEC_OP unary_expression
    | unary_operator cast_expression
    | SIZEOF unary_expression
    | SIZEOF OPEN_PAREN type_name CLOSE_PAREN
    ;

unary_operator
    ::= BITWISE_AND
    | MULTIPLICATION
    | PLUS
    | MINUS
    | BITWISE_NOT
    | NOT
    ;

cast_expression
    ::= unary_expression
    | OPEN_PAREN type_name CLOSE_PAREN cast_expression
    ;

multiplicative_expression
    ::= cast_expression
    | multiplicative_expression MULTIPLICATION cast_expression
    | multiplicative_expression DIVIDE cast_expression
    | multiplicative_expression MOD cast_expression
    ;

additive_expression
    ::= multiplicative_expression
    | additive_expression PLUS multiplicative_expression
    | additive_expression MINUS multiplicative_expression
    ;

shift_expression
    ::= additive_expression
    | shift_expression LEFT_OP additive_expression
    | shift_expression RIGHT_OP additive_expression
    ;

relational_expression
    ::= shift_expression
    | relational_expression LESS_THAN shift_expression
    | relational_expression GREATER_THAN shift_expression
    | relational_expression LE_OP shift_expression
    | relational_expression GE_OP shift_expression
    ;

equality_expression
    ::= relational_expression
    | equality_expression EQ_OP relational_expression
    | equality_expression NE_OP relational_expression
    ;

and_expression
    ::= equality_expression
    | and_expression BITWISE_AND equality_expression
    ;

exclusive_or_expression
    ::= and_expression
    | exclusive_or_expression BITWISE_XOR and_expression
    ;

inclusive_or_expression
    ::= exclusive_or_expression
    | inclusive_or_expression BITWISE_OR exclusive_or_expression
    ;

logical_and_expression
    ::= inclusive_or_expression
    | logical_and_expression AND_OP inclusive_or_expression
    ;

logical_or_expression
    ::= logical_and_expression
    | logical_or_expression OR_OP logical_and_expression
    ;

conditional_expression
    ::= logical_or_expression
    | logical_or_expression TERNARY expression COLON conditional_expression
    ;

assignment_expression
    ::= conditional_expression
    | unary_expression assignment_operator:a assignment_expression:e
    {: /* RESULT =  (Object)((String)a + (String)e);  */:}
    ;

assignment_operator
    ::= EQUALS //{: RESULT = sym.EQUALS; :}
    | MUL_ASSIGN //{: RESULT = sym.MUL_ASSIGN; :}
    | DIV_ASSIGN //{: RESULT = sym.DIV_ASSIGN; :}
    | MOD_ASSIGN //{: RESULT = sym.MOD_ASSIGN; :}
    | ADD_ASSIGN //{: RESULT = sym.ADD_ASSIGN; :}
    | SUB_ASSIGN //{: RESULT = sym.SUB_ASSIGN; :}
    | LEFT_ASSIGN //{: RESULT = sym.LEFT_ASSIGN; :}
    | RIGHT_ASSIGN //{: RESULT = sym.RIGHT_ASSIGN; :}
    | AND_ASSIGN //{: RESULT = sym.AND_ASSIGN; :}
    | XOR_ASSIGN //{: RESULT = sym.XOR_ASSIGN; :}
    | OR_ASSIGN //{: RESULT = sym.OR_ASSIGN; :}
    ;

expression
    ::= assignment_expression:a
    //{: RESULT = (Object)((String)a); :}
    | expression:e COMMA assignment_expression:a
    //{: RESULT = (Object)((String)e + "," + (String)a); :}
    ;

constant_expression
    ::= conditional_expression
    ;

declaration
    ::= declaration_specifiers SEMI_COLON
    | declaration_specifiers init_declarator_list SEMI_COLON
    ;
/* ANSI C
declaration_specifiers
    ::= storage_class_specifier
    | storage_class_specifier declaration_specifiers
    | type_specifier
    | type_specifier declaration_specifiers
    | type_qualifier
    | type_qualifier declaration_specifiers
    ;
    */
declaration_specifiers
    ::= storage_class_specifier
    | storage_class_specifier declaration_specifiers
    | type_specifier
    | type_specifier declaration_specifiers
    | type_qualifier
    | type_qualifier declaration_specifiers
    | DEFAULT declaration_specifiers
    ;

init_declarator_list
    ::= init_declarator
    | init_declarator_list COMMA init_declarator
    ;
/* ansi c
init_declarator
    ::= declarator
    | declarator EQUALS initializer
    ;
    */
init_declarator
    ::= declarator
    | declarator EQUALS initializer
    | declarator attributes
    | declarator attributes EQUALS initializer
    ;    
/*ansi c
storage_class_specifier
    ::= STATIC 
    ;
*/
storage_class_specifier
    ::= STATIC | COMMAND | EVENT | ASYNC | TASK | NORACE
    ;
type_specifier
    ::= VOID
    | CHAR
    | SHORT
    | INT
    | LONG
    | FLOAT
    | DOUBLE
    | SIGNED
    | UNSIGNED
    | struct_or_union_specifier
    | enum_specifier
    | TYPE_NAME
    | TEMPLATE
| VIRTUAL
| UINT8_T
| UINT16_T
| UINT32_T
| INT8_T
| INT16_T
| INT32_T
| BOOL
| EXPLICIT
| EXPORT
| INLINE
| ERROR_T
| RESULT_T
| PACKET_T 
| MESSAGE_T
    ;
/* ansi c
struct_or_union_specifier
    ::= struct_or_union IDENTIFIER:i OPEN_CURLY struct_declaration_list CLOSE_CURLY
    | struct_or_union OPEN_CURLY struct_declaration_list CLOSE_CURLY
    | struct_or_union IDENTIFIER:i
    ;*/
struct_or_union_specifier
    ::= struct_or_union IDENTIFIER:i OPEN_CURLY struct_declaration_list CLOSE_CURLY
    | struct_or_union OPEN_CURLY struct_declaration_list CLOSE_CURLY
    | struct_or_union IDENTIFIER:i
    | STRUCT AT IDENTIFIER:i attributes OPEN_CURLY struct_declaration_list CLOSE_CURLY
    | struct_or_union IDENTIFIER:i attributes OPEN_CURLY struct_declaration_list CLOSE_CURLY
    ;
/*ansi c
struct_or_union
    ::= STRUCT
    | UNION
    ;
    */
struct_or_union
    ::= STRUCT
    | UNION
    | NX_UNION
    | NX_STRUCT
    ;

struct_declaration_list
    ::= struct_declaration
    | struct_declaration_list struct_declaration
    ;

/* ansi c
struct_declaration
    ::= specifier_qualifier_list struct_declarator_list SEMI_COLON
    ;
    */

struct_declaration
    ::= specifier_qualifier_list struct_declarator_list SEMI_COLON
    | declarator attributes
    | declarator COLON constant_expression attributes
    ;

specifier_qualifier_list
    ::= type_specifier specifier_qualifier_list
    | type_specifier
    | type_qualifier specifier_qualifier_list
    | type_qualifier
    ;

struct_declarator_list
    ::= struct_declarator
    | struct_declarator_list COMMA struct_declarator
    ;

struct_declarator
    ::= declarator
    | COLON constant_expression
    | declarator COLON constant_expression
    ;
/*
enum_specifier
    ::= ENUM OPEN_CURLY enumerator_list CLOSE_CURLY
    | ENUM IDENTIFIER:i OPEN_CURLY enumerator_list CLOSE_CURLY
    | ENUM IDENTIFIER:i
    ;*/

enum_specifier
    ::= ENUM OPEN_CURLY enumerator_list CLOSE_CURLY
    | ENUM IDENTIFIER:i OPEN_CURLY enumerator_list CLOSE_CURLY
    | ENUM IDENTIFIER:i
    | ENUM IDENTIFIER:i attributes OPEN_CURLY enumerator_list CLOSE_CURLY
    ;  

enumerator_list
    ::= enumerator
    | enumerator_list COMMA enumerator
    ;

enumerator
    ::= IDENTIFIER:i
    | IDENTIFIER:i EQUALS constant_expression
    ;
/*ansi c
type_qualifier
    ::= CONST
    | VOLATILE
    | EXTERN
    ;
*/
type_qualifier
    ::= CONST
    | VOLATILE
    | EXTERN
    | attribute
    ;
       
declarator
    ::= pointer direct_declarator
    | direct_declarator
    ;
/* ansi c 
direct_declarator
    ::= IDENTIFIER:i
    | OPEN_PAREN declarator CLOSE_PAREN
    | direct_declarator OPEN_BRACE constant_expression CLOSE_BRACE
    | direct_declarator OPEN_BRACE CLOSE_BRACE
    | direct_declarator OPEN_PAREN parameter_type_list CLOSE_PAREN
    | direct_declarator OPEN_PAREN identifier_list CLOSE_PAREN
    | direct_declarator OPEN_PAREN CLOSE_PAREN
    ;
*/
direct_declarator
    ::= IDENTIFIER:i
    | OPEN_PAREN declarator CLOSE_PAREN
    | direct_declarator OPEN_BRACE constant_expression CLOSE_BRACE
    | direct_declarator OPEN_BRACE CLOSE_BRACE
    | direct_declarator OPEN_PAREN parameter_type_list CLOSE_PAREN
    | direct_declarator OPEN_PAREN identifier_list CLOSE_PAREN
    | direct_declarator OPEN_PAREN CLOSE_PAREN
    | IDENTIFIER:i DOT IDENTIFIER:e
    | direct_declarator instance_parameters OPEN_PAREN parameter_type_list CLOSE_PAREN
    ;
pointer
    ::= MULTIPLICATION
    | MULTIPLICATION type_qualifier_list
    | MULTIPLICATION pointer
    | MULTIPLICATION type_qualifier_list pointer
    ;

type_qualifier_list
    ::= type_qualifier
    | type_qualifier_list type_qualifier
    ;


parameter_type_list
    ::= parameter_list
    | parameter_list COMMA ELLIPSIS
    ;

parameter_list
    ::= parameter_declaration
    | parameter_list COMMA parameter_declaration
    ;
/* ansi c
parameter_declaration
    ::= declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers
    ;
    */
parameter_declaration
    ::= declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers
    | declaration_specifiers declarator attributes
    ;


identifier_list
    ::= IDENTIFIER:i
    | identifier_list COMMA IDENTIFIER:i
    ;

type_name
    ::= specifier_qualifier_list
    | specifier_qualifier_list abstract_declarator
    ;

abstract_declarator
    ::= pointer
    | direct_abstract_declarator
    | pointer direct_abstract_declarator
    ;

direct_abstract_declarator
    ::= OPEN_PAREN abstract_declarator CLOSE_PAREN
    | OPEN_BRACE CLOSE_BRACE
    | OPEN_BRACE constant_expression CLOSE_BRACE
    | direct_abstract_declarator OPEN_BRACE CLOSE_BRACE
    | direct_abstract_declarator OPEN_BRACE constant_expression CLOSE_BRACE
    | OPEN_PAREN CLOSE_PAREN
    | OPEN_PAREN parameter_type_list CLOSE_PAREN
    | direct_abstract_declarator OPEN_PAREN CLOSE_PAREN
    | direct_abstract_declarator OPEN_PAREN parameter_type_list CLOSE_PAREN
    ;

initializer
    ::= assignment_expression
    | OPEN_CURLY initializer_list CLOSE_CURLY
    | OPEN_CURLY initializer_list COMMA CLOSE_CURLY
    ;

initializer_list
    ::= initializer
    | initializer_list COMMA initializer
    ;
/* ansi c
statement
    ::= labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    ;
    */

statement
    ::= labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    | atomic_statement
    ;    
/*for nesc*/
atomic_statement ::= ATOMIC statement;
/*end*/

labeled_statement
    ::= IDENTIFIER:i COLON statement
    | CASE constant_expression COLON statement
    | DEFAULT COLON statement
    ;

compound_statement
    ::= OPEN_CURLY CLOSE_CURLY
    | OPEN_CURLY statement_list CLOSE_CURLY
    | OPEN_CURLY declaration_list CLOSE_CURLY
    | OPEN_CURLY declaration_list statement_list CLOSE_CURLY
    ;

declaration_list
    ::= declaration
    | declaration_list declaration
    ;

statement_list
    ::= statement
    | statement_list statement
    ;

expression_statement
    ::= SEMI_COLON
    | expression SEMI_COLON
    ;

selection_statement
    ::= IF OPEN_PAREN expression CLOSE_PAREN statement
    | IF OPEN_PAREN expression CLOSE_PAREN statement ELSE statement
    | SWITCH OPEN_PAREN expression CLOSE_PAREN statement
    ;


iteration_statement
    ::= WHILE OPEN_PAREN expression CLOSE_PAREN statement
    | DO statement WHILE OPEN_PAREN expression CLOSE_PAREN SEMI_COLON
    | FOR OPEN_PAREN expression_statement expression_statement CLOSE_PAREN statement
    | FOR OPEN_PAREN expression_statement expression_statement expression CLOSE_PAREN statement
    ;

jump_statement
    ::= GOTO IDENTIFIER:i SEMI_COLON
    | CONTINUE SEMI_COLON
    | BREAK SEMI_COLON
    | RETURN SEMI_COLON
    | RETURN expression SEMI_COLON
    ;

translation_unit
    ::= external_declaration
    | translation_unit external_declaration
    ;

external_declaration
    ::= function_definition
    | declaration
    ;
/* ansi c
function_definition
    ::= declaration_specifiers declarator declaration_list compound_statement
    | declaration_specifiers declarator compound_statement
    | declarator declaration_list compound_statement
    | declarator compound_statement
    ;
    */
function_definition
    ::= declaration_specifiers declarator declaration_list compound_statement
    | declaration_specifiers declarator compound_statement
    | declarator declaration_list compound_statement
    | declarator compound_statement
    | declaration_specifiers declarator attributes declaration_list compound_statement
    | declarator attributes declaration_list compound_statement
    | declaration_specifiers declarator attributes compound_statement
    | declarator attributes compound_statement
    ;

/* NesC Gramatic *//*
nesC_file    	        	   	::=
								includes_list interface
                    		    |
                    		    includes_list module
								|
                   	    		includes_list configuration
								;

includes_list					::=
								includes_list includes
								|
								includes
								/*|
								/* epsilon *//*
								;

includes						::=
								INCLUDES identifier_list SEMI_COLON
								;

interface						::=
								INTERFACE IDENTIFIER:i OPEN_CURLY declaration_list CLOSE_CURLY
								;

module							::=
								MODULE IDENTIFIER:i specification module_implementation
								;

module_implementation			::=
								IMPLEMENTATION OPEN_CURLY translation_unit CLOSE_CURLY
								;

configuration					::=
								CONFIGURATION IDENTIFIER:i specification configuration_implementation
								;

configuration_implementation	::=
								IMPLEMENTATION OPEN_CURLY component_list connection_list CLOSE_CURLY
								;

component_list					::=
								component_list components
								|
								components
								/*|
								/* epsilon */	/*
								;

components						::=
								COMPONENTS component_line SEMI_COLON
								;

component_line					::=
								renamed_IDENTIFIER:i
								|
								component_line COMMA renamed_IDENTIFIER:i
								;

renamed_IDENTIFIER:i				::=
								IDENTIFIER:i
								|
								IDENTIFIER:i AS IDENTIFIER:i
								;

connection_list					::=
								connection
								|
								connection_list	connection
								;

connection						::=
								endpoint EQUALS endpoint
								|
								endpoint WIRES_TO endpoint
								|
								endpoint WIRES_FROM endpoint
								;

endpoint						::=
								IDENTIFIER:i_path
								|
								identifier_pathOPEN_BRACE argument_expression_list CLOSE_BRACE
								;

IDENTIFIER:i_path					::=
								IDENTIFIER:i
								|
								identifier_pathDOT IDENTIFIER:i
								;

specification					::=
								OPEN_CURLY uses_provides_list CLOSE_CURLY
								;

uses_provides_list				::=
								uses_provides
								|
								uses_provides_list uses_provides
								;

uses_provides					::=
								USES specification_element_list
								|
								PROVIDES specification_element_list
								;

specification_element_list		::=
								specification_element
								|
								OPEN_CURLY specification_elements CLOSE_CURLY
								;

specification_elements			::=
								specification_elements specifiaction_element
								|
								specification_element
								;	

specification_element			::=
								declaration
								|
								INTERFACE renamed_IDENTIFIER:i paramenters
								;

paramenters						::=
								OPEN_BRACE parameter_type_list OPEN_BRACE
								|
								/* epsilon *//*
								;

/*test c*//*
identifier_list ::= identifier_list  IDENTIFIER:i COMMA | DOT;
declaration_list ::= declaration_list  IDENTIFIER:i COMMA | DOT;
translation_unit ::= translation_unit  IDENTIFIER:i COMMA | DOT;
argument_expression_list ::= argument_expression_list  IDENTIFIER:i COMMA | DOT;
uses_provides ::= uses_provides  IDENTIFIER:i COMMA | DOT;
specifiaction_element ::= specifiaction_element  IDENTIFIER:i COMMA | DOT;
declaration ::= declaration  IDENTIFIER:i COMMA | DOT;
parameter_type_list ::= parameter_type_list  IDENTIFIER:i COMMA | DOT;*/
/* changed rules C Gramatic for NesC */
						
/*

module_list                                   ::= module_list module_statement_list 
                                                | module_statement_list
                                                ;

module_statement_list                         ::= PROVIDES OPEN_CURLY module_statement CLOSE_CURLY 
                                                | USES OPEN_CURLY module_statement CLOSE_CURLY ;

module_statement                              ::= module_statement INTERFACE IDENTIFIER:i SEMI_COLON
                                                | /*epsilon*//*
                                                ;

implementation_content                        ::= components_list  statement_implementation_list 
                                                | statement_advanced_implementation_list 
                                                | /*epsilon*//*
                                                ;

components_list                               ::= COMPONENTS component_list SEMI_COLON | /*epsilon*//*;

component_list                                ::= component_list COMMA IDENTIFIER:i | IDENTIFIER:i;

statement_list                                ::= statement_list statement | statement;

statement_advanced_implementation_list        ::= statement_advanced_implementation_list statement_advanced_implementation 
                                                | statement_advanced_implementation;

statement_advanced_implementation             ::= COMMAND RESULT_T IDENTIFIER:i DOT IDENTIFIER:i OPEN_PAREN IDENTIFIER:i_value_list CLOSE_PAREN OPEN_CURLY statement_advanced_implementation_items CLOSE_CURLY 
                                                | EVENT RESULT_T IDENTIFIER:i DOT IDENTIFIER:i OPEN_PAREN IDENTIFIER:i_value_list CLOSE_PAREN OPEN_CURLY statement_advanced_implementation_items CLOSE_CURLY
                                                ; 

statement_advanced_implementation_items       ::= statement_advanced_implementation_items statement_advanced_implementation_return_item
                                                | statement_advanced_implementation_item 
						|/*epsilon*//*
						;

statement_advanced_implementation_return_item ::= RETURN statement_advanced_implementation_item;

statement_advanced_implementation_item        ::= CALL IDENTIFIER:i DOT IDENTIFIER:i OPEN_PAREN IDENTIFIER:i_value_list CLOSE_PAREN SEMI_COLON 
                                                | IDENTIFIER:i SEMI_COLON;

IDENTIFIER:i_value_list                         ::= IDENTIFIER:i_value_list COMMA IDENTIFIER:i 
                                                | IDENTIFIER:i_value_list COMMA values_set 
                                                | values_set 
                                                | IDENTIFIER:i 
                                                | /*epsilon*//*
                                                ;

values_set                                    ::= INTEGER | FLOAT | CHARACTER | STRING;
statement                                     ::=  
                                                  COMMAND RESULT_T IDENTIFIER:i OPEN_PAREN type_list CLOSE_PAREN SEMI_COLON
					          {:
							System.out.println("statement");
    						  :}
   						| EVENT RESULT_T IDENTIFIER:i OPEN_PAREN type_list CLOSE_PAREN SEMI_COLON
						{:
							System.out.println("statement");
					        :}
					        ;

type_list                                     ::= type_list COMMA types_set IDENTIFIER:i | types_set IDENTIFIER:i | /*epsilon*/ /*;

types_set                                     ::= CHAR | UINT8_T | UINT16_T | UINT32_T | INT8_T | INT16_T | INT32_T |EXPLICIT | EXPORT 
						|INLINE | ERROR_T | RESULT_T | PACKET_T | MESSAGE_T | STRUCT | ENUM | BOOL | INT;

statement_implementation_list                 ::= statement_implementation_list statement_implementation | statement_implementation;

statement_implementation                      ::=
						IDENTIFIER:i_pro WIRES_TO IDENTIFIER:i_pro SEMI_COLON
						{:
						System.out.println("statement");
						:}
						;

IDENTIFIER:i_pro                                ::= IDENTIFIER:i_pro DOT IDENTIFIER:i | IDENTIFIER:i  ;
    
*/
/* vim: :set ft=java: */